# 4. HTTP 帧

一旦建立了 HTTP/2 连接，终端之间就可以开始交换帧了。
## 4.1 帧格式

所有的帧都以一个 9 字节的报头开始，后接变长的载荷：
```
+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+=+=============================================================+
|                   Frame Payload (0...)                      ...
+---------------------------------------------------------------+
```

报头部分的字段定义如下：
+ `Length`: 载荷的长度，无符号 24 位整型。**对于发送值大于 2^14 （长度大于 16384 字节）的载荷，只有在接收方设置`SETTINGS_MAX_FRAME_SIZE`为更大的值时才被允许**
	
  注：帧的报头 9 字节不算在 length 里。
+ `Type`: 8 位的值表示帧类型，决定了帧的格式和语义。协议实现上必须忽略任何未知类型的帧。
+ `Flags`: 为 Type 保留的 bool 标识，大小是 8 位。对确定的帧类型赋予特定的语义，否则发送时必须忽略（设置为 0x0).
+ `R`: 1 位的保留字段，尚未定义语义。发送和接收必须忽略 (0x0).
+ `Stream Identifier`: 31 位无符号整型的流标示符。其中 0x0 作为保留值，表示与连接相关的 frames 作为一个整体而不是一个单独的流。
## 4.2 帧大小

载荷的大小受接收方设置的`SETTINGS_MAX_FRAME_SIZE`所限，而这个值的取值区间是 [2^14  (16384), 2^24-1 (16777215)] 字节。
必须能够接收并且至少能够处理 2^14 字节大小的帧，外加 9 字节的报头。在描述帧的大小时，不包含帧的报头部分。
注：某些类型的帧，如 PING, 会在允许传输的载荷大小上附加额外的限制。
终端必须响应一个错误码 FRAME_SIZE_ERROR ----如果帧大小超过了 SETTINGS_MAX_FRAME_SIZE 中的定义或超过了对特定类型帧的大小限制，抑或是帧太小以至于无法容纳下必要的元信息。如果一个帧的*帧大小错误*可能改变整个连接的状态，那么必须作为连接错误来对待；这包括任何携带报头区块 (HEADERS, PUSH_PROMISE, CONTINUATION) 的帧，SETTINGS 帧，以及任何带有流标识符为 0x0 的帧。
终端不必完整填充一个帧的所有空间。更小的帧能提高响应速度。对于时间敏感的帧来讲（如 RST_STREAM, WINDOW_UPDATE, PRIORITY), 发送大块的帧可能导致延迟，如果传输链路被一个大块帧阻塞，很可能会带来性能损耗。
## 4.3 Header 压缩和解压

HTTP/2 与 HTTP/1 的报头结构一样，一键多值。除了用于 HTTP 请求和响应之外还用于 server push 操作。
### 压缩&分片
报头列表包含 0 个或多个报头字段。传输过程是：先用压缩把报头列表序列化成一个报头区块。然后将这个区块分割成一个或多个字节序列，称之为区块分片。分片可以作为 HEADERS 帧，PUSH_PROMISE 帧或者 CONTINUATION 帧的载荷。
其中 Cookie 字段通过 HTTP mapping 特殊处理。
### 解压&重组
报文接收端将分片拼接起来以重组报头区块，然后解压区块得到原始的报头列表。
一个完整地报头区块可以由下面任意一种结构组成：
+ 一个设置了`END_HEADERS`标记的`HEADERS`或`PUSH_PROMISE`帧。
+ 一个`END_HEADERS`标记置空的`HEADERS`或`PUSH_PROMISE` 帧，后接一个或多个`CONTINUATION`帧，并且最后一个`CONTINUATION`帧`END_HEADERS`标记。
报头压缩是个**有状态**的过程。整个连接复用同一个压缩和解压上下文。
报头区块中发生的解码错误必须当成连接错误处理，类型为`COMPRESSION_ERROR`.

每个报头区块被当做离散的单元处理。必须确保这些区块传输的连续性，期间不能交叉其他类型的或来自任何其他流的帧。`HEADERS`与`PUSH_PROMISE`的`CONTINUATION`传输序列中最后一帧一定设置了`END_HEADERS`标记。这保证了报头区块在逻辑上等价于单个帧。
报头区块的分片只能作为`HEADERS`, `PUSH_PROMISE`以及`CONTINUATION`帧的载荷存在。因为这些帧携带的数据可能修改接收方维护的压缩上下文：接收方拿到这三种类型之一的帧之后需要重组区块并解压，即便这些帧将被丢弃。如果无法解压区块，接收方必须以一个类型为`COMPRESSION_ERROR`的错误断开连接。
