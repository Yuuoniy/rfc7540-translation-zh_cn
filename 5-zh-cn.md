# 5. 流和多路复用

在一个 HTTP/2 的连接中，流是服务器与客户端之间用于帧交换的一个独立双向序列。流有几个重要的特点：
+ 一个 HTTP/2 连接可以包含多个并发的流，各个端点从多个流中交换 frame
+ 流可以被客户端或服务器单方面建立，使用或共享
+ 流也可以被任意一方关闭
+ frames 在一个流上的发送顺序很重要。接收方将按照他们的接收顺序处理这些 frame. 特别是`HEADERS`和`DATA` frame 的顺序，在协议的语义上显得尤为重要。
+ 流用一个整数（流标识符）标记。端点初始化流的时候就为其分配了标识符。
## 5.1 流的状态

下图展示了流的生存周期：
```
                         +--------+
                 send PP |        | recv PP
                ,--------|  idle  |--------.
               /         |        |         \
              v          +--------+          v
       +----------+          |           +----------+
       |          |          | send H /  |          |
,------| reserved |          | recv H    | reserved |------.
|      | (local)  |          |           | (remote) |      |
|      +----------+          v           +----------+      |
|          |             +--------+             |          |
|          |     recv ES |        | send ES     |          |
|   send H |     ,-------|  open  |-------.     | recv H   |
|          |    /        |        |        \    |          |
|          v   v         +--------+         v   v          |
|      +----------+          |           +----------+      |
|      |   half   |          |           |   half   |      |
|      |  closed  |          | send R /  |  closed  |      |
|      | (remote) |          | recv R    | (local)  |      |
|      +----------+          |           +----------+      |
|           |                |                 |           |
|           | send ES /      |       recv ES / |           |
|           | send R /       v        send R / |           |
|           | recv R     +--------+   recv R   |           |
| send R /  `----------->|        |<-----------'  send R / |
| recv R                 | closed |               recv R   |
`----------------------->|        |<----------------------'
                         +--------+

   send:   发送这个 frame 的终端
   recv:   接受这个 frame 的终端

   H:  HEADERS 帧 （隐含 CONTINUATION 帧）
   PP: PUSH_PROMISE 帧 （隐含 CONTINUATION 帧）
   ES: END_STREAM 标记
   R:  RST_STREAM 帧
```

该图只展示了流的状态转换以及 frame 和标记如何对转换产生影响。这方面，`CONTINUATION`frames 不会导致状态的转换，他们只是跟在`HEADERS`或`PUSH_PROMISE` frame 后面的有效组成部分。
状态转换的用途，对于设置了`END_STREAM`标记的 frame 来说，`END_STREAM`被当做一个分开的事件处理。设置了`END_STREAM`标记的`HEADERS` frame 会导致两次状态转换。
在传输过程中，每个端点对流状态的主观认识可能不同。这些终端不会协商流的创建，都是由终端独立创建的。端点的流状态不同会带来负面影响：在发送了`RST_STREAM`之后流处于关闭状态，而 frame 可能在流关闭之后才到达。
流有如下状态：
+ `idle`
	所有流最初状态都是`idle`.  
  下面描述了流从`idle`状态到其它状态的几种可能转换：
  - 发送或接收到一个`HEADERS`frame 会使流状态变换`open`. 流标识符的选择参见 5.1.1 里的描述。收到相同的`HEADERS`frame 会导致流立即变为`half-close`状态。
  - (Sending a PUSH\_PROMISE frame on another stream reserves the idle stream that is identified for later use.) 在另一个流上发送一个`PUSH_PROMISE`frame 被标识为以后使用。预留流的状态对应转换到`reserved (local)`.
  - (Receiving a PUSH\_PROMISE frame on another stream reserves an idle stream that is identified for later use.) 在另一个流上接收一个`PUSH_PROMISE`frame 被标识为以后使用。预留流的状态对应转换到`reserved (remote)`.
  - 注意`PUSH_PROMISE`frame 并不在 idle 流上发送，只是 promised 流的 ID 字段引用了新的 reserved 流。
	在`idle`状态接收到任何非`HEADERS`或`PUSH_PROMISE`frame 必须视为连接错误，错误类型为`PROTOCOL_ERROR`

+ `reserved (local)`
	处于这种状态的流表示它已经发送了一个`PUSH_PROMISE`frame 并成为 promised 流。`PUSH_PROMISE`frame 通过关联一个由远程对等点初始化的流来转换 idle 流到 reserved 流。
  处于这个状态的流，只有下面的几种可能状态转换：
  - 端点发送一个`HEADERS`frame, 流进入`half-closed (remote)`状态。
  - 任何一个端点发送一个`RST_STREAM`frame, 流变成`closed`状态。这将释放一个流保留的资源。
	端点不准发送除`HEADERS`, `RST_STREAM`或`PRIORITY`之外任何类型的 frame.

  这一状态可能收到`PRIORITY`或`WINDOW_UPDATE`frame. 除了`RST_STREAM`, `PRIORITY`以及`WINDOW_UPDATE`frame 之外，收到其他类型的 frame 必须视为`PROTOCOL_EROR`类型的连接错误。
+ `reserved (remote)`
	如果一个流已被远程对等点保留，状态就会变成`reserved(remote)`.  
  可能的转换如下：
  - 收到一个 HEADERS frame 导致状态变为 half-close(local)
  - 任何端点发送一个`RST_STREAM`frame 会导致状态变成`closed`, 并释放流保留的资源。
  端点可以发送一个 PRIORITY frame 以重新确定 reserved 流的优先级次序。不允许发送除 RST_STREAM, WINDOW_UPDATE 或 PRIORITY 之外的 frame.

  在一个流上拿到非 HEADERS, RST_STREAM 或 PRIORITY 的 frame 必须视为`PROTOCOL_EROR`类型的连接错误。
+ `open`
	任何一对等方可以使用 open 状态的流发送任意类型的 frame. 这一状态下，发送方会监视给出的流级别和流控范围。
  在任意一方发送设置了 END_STREAM 标记的 frame 后，流状态会变为 half-closed 的其中一个状态：如果一方发送了该 frame, 其流变为 half-closed(local); 如果一方收到该 frame, 流变为 half-closed(remote).

  在这个状态发送 RST_STREAM frame 可以使状态立即变成 closed.

+ `half-closed (local)`
	处于这个状态的流不能发送除 WINDOW\_UPDATE, PRIORITY 以及 RST\_STREAM 之外的 frame.

  收到一个标记了 END_STREAM 的 frame 或者发送一个 RST_STREAM frame, 都会使状态变成 closed.

  端点允许接收任意类型的 frame. 便于后续接收用于流控的 frame, 使用 WINDOW_UPDATE frame 提供流控 credit 很有必要。接收方可以选择忽略 WINDWO_UPDATE frame, (which might arrive for a short period after a frame bearing the END_STREAM flag is sent.)

  收到的 PRIORITY frame 用于重定流的优先级次序（依据流的标记而定）

+ `half-closed (remote)`
	处于这个状态的流，对端不再用来发送 frame 了。并且端点也无需继续维护接收方流控窗口。
  如果端点收到额外的 frame, 并且不是 WINDOW_UPDATE, PRIORITY 或 RST_STREAM, 那么必须响应一个类型为 STREAM_CLOSED 的流错误。
  这一状态下的流可以发送任意类型的 frame. 端点仍会继续监视已知的流级别和流控范围。
  发送一个 END_STERAM 标记的 frame 或任意一个对等方发送了 RST_STREAM frame 都会使流变为 closed.

+ `closed`
	closed 标识终止状态。
  在一个 closed 的流上不允许发送 PRIORITY 之外的其他 frame. 端点在收到 RST_STREAM frame 后又收到非 PRIORITY 的 frame 的话，一定被视为流错误对待（类型 STREAM_CLOSED).

  同样，收到 END_STREAM 标记后又收到**非如下描述**的 frame, 会触发一个连接错误（类型 STREAM_CLOSED):

  发送了包含 END_STREAM 标记的 DATA 或 HEADERS frame 后的一小段时间内，允许 WINDOW_UPDATE 或 RST_STREAM frame 被接收。直到远程对等端收到并处理了 RST_STERAM 或包含 END_STREAM 标记的 frame, 才可以发送这些类型的 frame.
  假如在发送了 END_STREAM 后已明显过了超时时间，这时却再次收到 frame, 尽管终端可以选择把这个 frame 当成 PROTOCOL_ERROR 类型的连接错误来处理，但无论如何最终**必须**忽略这种情况下收到的 WINDOW_UPDATE 或 RST_STREAM frame.

  PRIORITY 帧可从 closed 流上发到优先级更高的流（取决于 closed 流）. 终端应该处理 PRIORITY 帧，尽管他们可能因为流已经从依赖树中移除而被忽略。
  如果是发送 RST_STREAM 帧的原因让状态转换到了 closed, 收到 RST_STREAM 的对等端这时可能已经发送了 RST_STREAM 或者入队等待发送中，但是已经在流上传输的帧是不可以被撤销的。这时，终端必须忽略从 closed 的流上再取得的帧，如果这个 closed 流已经发送了 RST_STREAM 帧。终端也可以选择一个超时时间，忽略在此之后到达的帧，并一律视作错误。
  在发送了 RST_STREAM 之后收到的流控帧（比如 DATA 帧）也会被用于计算当前连接的流控窗口。(are counted toward the connection flow-control window.) 尽管这些帧有可能被忽略掉，但是因为他们在发送方收到 RST_STREAM 之前被发送了，所以发送方仍有可能会根据这些帧计算流控窗口大小。
  终端发送了 RST_STREAM 帧之后可以再接收一个 PUSH_PROMISE 帧。PUSH_PROMISE 帧会将流状态变为 reserved 即使相关的流已经被重置。因此需要一个 RST_STREAM 帧去关闭不再需要的 promised 流。
本文档中没有给出更具体说明的地方，对于收到的那些未在上述状态描述中明确认可的帧，协议实现上应该视这种情况为一个类型为 PROTOCOL_ERROR 的连接错误。另外注意 PRIORITY 帧可以在流的任何一个状态被发送/接收。忽略未知类型的帧。
### 5.1.1 Stream 标识符

每个流都用 31 位无符号整型标识。客户端初始化流时必须使用奇数做标识，而那些被服务器初始化的流则要使用偶数做标识。注：流标识符 0x0 用于连接控制消息，不能用于建立一个新的流。
用于升级到 HTTP/2 的 HTTP/1.1 请求会以一个 0x1 为标识的流响应。升级完成后，客户端流 0x1 处于 half-closed(local) 状态。因此，0x1 不能被客户端（从 HTTP/1.1 升级过来的）选作新的流标示符。
新建立的流标识符必须在数字排序上大于所有由该端系统已打开或保留的流。这个要求制约了 HEADERS 帧打开的流和 PUSH_PROMISE 帧保留的流。当接收到不期望的标识符时，端系统必须响应一个类型为 PROTOCOL_ERROR 的连接错误。
首次使用一个新的流标识符会隐式关闭所有该端系统初始化的处于 idle 状态且标识符更小的流。就是说，如果一个客户端通过 7 号流发送了一个 HEADERS 帧，并且它尚未使用 5 号流发送过帧，那么当 7 号流上的第一个帧已发送或接收时，5 号流就会变为 closed 状态。
流标识符不能被重用。而长连接会占用端系统的流标识符可用空间。如果一个客户端无法建立新的流了，那么他可以选择建立新连接来创建新的流。同样，当服务器不能建立新的流时，可以发送一个 GOAWAY 帧以便客户端强制打开一个到服务器的新连接来创建新的流。
### 5.1.2 流的并发性

一个对等端可以通过 SETTINGS 帧的`SETTINGS_MAX_CONCURRENT_STREAMS`字段限制活跃状态的流的并发数，流的最大并发量设置是特定于每个端系统而言的，并且只作用于收到设置的对等端。也就是说，客户端指定服务器可用来初始化流的最大并发数，反之亦然。
处于 open 或 half-closed 状态的流，其数量受最大可打开流数量所限。任意这三种状态（译注：half-closed 包括 remote 和 local 两种状态）的流数量都受到`SETTINGS_MAX_CONCURRENT_STREAMS`的限制。而 reserved 状态的流则没这种限制。
端系统的配置不准超过由其对等端所设置的最大限度。如果一个端系统收到了 HEADERS 帧，并且帧的设置超过了该端系统的流最大并发限制，那么这种情况必须视为一个类型为 PROTOCOL_ERROR 或 REFUSED_STREAM 的流错误来对待，错误码的选择取决于端系统是否希望自动重试（详见 8.1.4 章节）.

如果一个端系统希望减小`SETTINGS_MAX_CONCURRENT_STREAMS`到一个比当前打开流的总量还要低的一个值，两种情况可供选择：或者直接关闭那些超过限制的流，或者等待这些流完成传输。
## 5.2 流控

流的多路复用会让 TCP 连接的使用产生竞争，这会导致流的阻塞。流控手段确保同一连接上的流互相之间不会产生严重的妨碍。流控既可用于某个单独的流，也可用于整个连接。
HTTP/2 通过使用 WINDOW_UPDATE 帧提供了流控功能。
### 5.2.1 流控原则

HTTP/2 流允许在不修改原有协议的基础上使用一系列流控算法。流控具有以下特点：
1. 流控针对于连接。所有类型的流控都作用于两个单跳的端系统之间，而非整个端到端链路。
2. 流控基于 WINDOW\_UPDATE 帧实现。接收者告知他们准备在一个流上以及整个连接上分别接收多少字节。这属于基于信用的模型。
3. 流控具有方向性，且完全由接收者控制。接收方可以选择给每个流和整个连接设置期望的任意窗口大小。发送方必须遵循接收者施加的流控限制。所有客户端和服务器以及中间设施，作为接收方均独立声明其流控窗口，并在发送时同样遵循其对等端设置的流控限制。
4. 对于所有的流和连接，流控窗口的初始大小是 65535 字节 (2^16).
5. 帧的类型也决定了是否要在这个帧上应用流控。对于这篇文档中提到的帧，只有 DATA 帧是流控的作用对象。其他所有类型的帧均不占用流控窗口空间，这保证重要的控制帧不会因流控被阻塞。
6. 流控不能被禁用
7. HTTP/2 只定义了 WINDOW\_UPDATE 帧的格式和语义。这篇文当中并未规定接收者何时发送这个帧或是值如何设定，同样没有规定发送者如何选择发送分组。协议的实现允许选择任意一种符合其需求的算法。
协议的实现也需要负责：管理基于优先级发送请求和响应，选择避免请求的队首阻塞，以及管理流的创建。这些选择算法可以与任何流控算法协同工作。
### 5.2.2 合理使用流控

流控的目的是保护端系统使之在资源约束下执行操作。例如，一个代理服务器需要在许多连接之间共享内存，这些连接里可能有一条速度比较慢的上游连接和一条比较快的下游连接。流控关注的情况是：接收者尚未处理完一个流上的数据，然而想要处理同一连接上其他流的数据。
如果部署时不需要这个功能，可以把流控窗口设为最大值 (2^31-1), 并在收到任意数据时发送一个 WINDOW_UPDATE 帧。这相当于禁用了接收方的流控限制。相反地，发送方总是遵循接收方告之的流控窗口。
有资源约束情况下的部署，可以使用流控来限制对等方可以消费的资源（比如内存）. 需要注意的是，如果不了解**带宽时延积**就启用了流控，对于可用的网络资源来说这可能并非是最优的使用方案。（见译注）

即便对当前网络的带宽时延积有了充分的了解，流控的实现也是很难的。启用流控时，接收方必须要立刻读取 TCP 的接收缓冲区，否则达到了临界点时，对于 WINDOW\_UPDATE 来说，这时既不能读取也不能采取其他行动，就会导致死锁产生。
> **译注**

> 带宽时延积：即链路上的最大比特数，也称以比特为单位的链路长度。计算方法：带宽 × ACK 时延

> 实际传输数据的时候不可能每个报文发送后就立即收到确认，如果每报文等待确认就会导致传输速率变慢，所以 TCP 允许在没收到上一个确认前发送下 N 个报文，但是发送报文不能超过窗口大小，如果窗口、<带宽时延积，就会导致有些响应报文还未到达发送端时，发送端就已经达到窗口大小，这时发送端就必须重新发送之前的报文（而实际上接收端已经有响应了，只是未到达发送端）, 这样就会导致报文有大量重传，叠加效应就会导致传输速度远低于带宽（被无用的重传给占用了）

> 相反，窗口足够大，发送端连续发送的 N 个报文都能在窗口内收到响应，不会有数据重传，理论上的传输速度就会等于带宽值。
## 5.3 流的优先级

客户端可以给一个新的流分配一个优先级，做法是在用来打开流的 HEADERS 帧中包含优先次序信息。在其他任何时间，可以用 PRIORITY 帧改变一个流的优先级。
优先次序的目的是在并发流管理的时候，允许端系统选择它所期望的对等端分配资源方式。最重要的是，当发送受到限制的情况下，可以通过优先级选择使用哪个流来传输帧。
流可以通过被标记为其他流完成的依赖的方法赋予优先级。每个依赖被赋予一个相对权重，它用一个数值表示。对于依赖这个流的其他流拥有的可用资源，这个数值决定了的他们的相对比重。
显式设置过优先级的流将被优先安排。但这种优先并不保证一个优先级高的流能得到优先处理或者优先传输。端系统不能用优先级强迫其对等方按照特定顺序处理并发流。所以说，优先级仅仅作为一种建议存在。
可以忽略消息中的优先级信息。默认情况下使用显式提供的任何优先级值。
### 5.3.1 流的依赖关系

每个流可以显式指定依赖其他的流。如果流被其他流所依赖，这就表明这个流在资源的分配上优先于它的从属流。
不依赖其他任何流的流，会被隐式指定依赖标识符为 0x0 的流。换句话说，并非实际存在的流 0x0 成为了依赖树的根节点。
依赖于其他流的流称作一个从属流。上游被依赖的流称作上级流。如果一个流的依赖项目前不在依赖树中（比如 idle 状态的流）,
这个流就会被赋予默认优先级。
当给一个流添加依赖时，这个流就成为上级流的一个新依赖项。共享同一个上级流的多个从属流之间并没有严格的顺序要求。
比如，流 B 和 C 依赖于流 A, 并且流 D 在创建时也把 A 作为依赖添加进来，那么 A 的依赖项顺序可以是任意的 (BCD/DBC...):

```
   A                 A
  / \      ==>      /|\
 B   C             B D C
```

一个专属 (exclusive) 标记允许新依赖等级的插入。拥有专属标记的流会成为其上级流的唯一依赖项，
而上级流的其余依赖项会变成这个专属流的依赖项。在前一个例子中，如果使用一个对 A 的专属依赖创建 D,
那么 D 就会变成 B 和 C 的上级流：
```
                     A
   A                 |
  / \      ==>       D
 B   C              / \
                   B   C
```

对于依赖树内部的一个从属流，直到它依赖的所有流（包括上级流依赖链上的流，直到 0x0) 都已处于 closed 状态，
或者它不可能再使用这些上级流时，它才能被分配到到资源。
流不可以依赖自身。否则端系统必须将此视作类型为 PROTOCOL_ERROR 的流错误。
### 5.3.2 依赖权重

所有的从属流会分配到一个介于 [1, 256] 之间的整数，表示权重。
依赖于相同上级的流应该依据其权重比例分配资源。因此，如果权重为 4 的流 B 和权重为 12 的流 C 都依赖于流 A,
并且 A 上不会有任何动作，那么 B 会分得 1/4 的资源，C 分得 3/4 的资源。
### 5.3.3 优先级（依赖）重排

流的优先级可以通过 PRIORITY 帧来改变。添加依赖会让这个流对其上级流产生依赖关系。
如果上级流重置了优先级，它的从属流也会跟随其变化。
给重值优先级的流添加带有专属标记的依赖会导致其上级流的所有依赖项成为这个重置优先级的流的依赖项。
如果流把它的一个依赖项做为一个新的依赖，那么之前的从属流首先会成为重置优先级的流（译注：当前描述的流）的前一个上级的依赖项。
而那些被移动的依赖项的权重不会改变。
考虑这样一棵依赖树：B 和 C 依赖于 A, D 和 E 依赖于 C, F 依赖于 D. 如果把 A 设成 D 的一个依赖项（即 A 依赖 D),
那么最后 D 就会替换 A 在树中的位置。所有其他的依赖关系保持不变，除非用专属标记重置了 A 的优先级（这会导致 F 直接依赖于 A).

```
  x                x                x                 x
  |               / \               |                 |
  A              D   A              D                 D
 / \            /   / \            / \                |
B   C     ==>  F   B   C   ==>    F   A       OR      A
   / \                 |             / \             /|\
  D   E                E            B   C           B C F
  |                                     |             |
  F                                     E             E
                （中间过程）      （未使用专属标记）     （使用了专属标记）
```

### 5.3.4 优先级状态管理

当一个流从依赖树中被移除时，它的依赖项可能直接变成它直接上级流的依赖项，之后会依据这些依赖项在直接上级流的原有依赖项所占权重比例来重新计算新的依赖项权重。
从依赖树中移除流会导致一些优先级信息的丢失。资源是在具有相同上级流的从属流之间共享的，这意味着如果这些从属流中有一个处于关闭状态或阻塞住了，其上分配到任何闲置资源将重新分配到其临近的流上。如果公共的依赖项被移除，那么对依赖项有依赖的那些流会和上一层的流共享资源。
例如，假如流 A 和流 B 共享同一个上级流，并且流 C 和流 D 都依赖流 A. 移除流 A 之前，如果 A 和 D 不再使用，那么流 C 接收流 A 专享的所有资源。如果流 A 被移除，它的权重会在 C 和 D 之间分配。如果流 D 仍无法继续使用，那么流 C 得到的资源比重会减小。依据平等的初始权重，C 能得到 1/3 而非 1/2 的可用资源。
一个流上的优先级信息正在变化时，这个流可能变成 closed 了。如果一个依赖项中有标识的流并没有对应的的优先级信息，那么它的从属流会替代它分配一个默认的优先级。这潜在的创建一个非最优的优先级，因为瘤可能分配到一个并非预期的优先级。
为了避免这些问题，在流 closed 之后，端系统还应该保存一段时间流的优先级状态。保存的时间越长，流分得非预期或默认优先级的可能性就越小。
同样地，idle 状态的流可能被分配优先级或成为其他流的上级。这就相当于在依赖书中创建一个节点组，同时也赋予了优先级更灵活的表达方式。idle 流最初被分配了默认优先级。
流上优先级信息的保留不受 SETTINGS_MAX_CONCURRENT_STREAMS 值的影响，因此为了维护这些信息可能会给一个端系统带来巨大的负担。因此，可能需要限制一下保存的优先级状态信息的数量。
端系统维护的额外状态信息数量可以依负载而定。高负载情况下，可以取消优先级状态以防止资源的不合理使用。极端情况下，端系统甚至可以取消活跃的或 reserved 流的优先级状态。如果施加了限制，端系统应该至少维护和每个流所设置的 SETTINGS_MAX_CONCURRENT_STREAMS 一样多的状态。协议的实现也应该尽量为优先级树中正在使用的流保存状态。
如果已经保存了足够多的状态来改变优先级，端系统通过接收一个 PRIORITY 帧来改变一个 closed 流优先级，那么它应该修改这个流的依赖项。
### 5.3.5 默认优先级

所有的流初始化时都会成为 0x0 的非专属依赖。推送流在初始化时则依赖于和它们相关联的流。
不管何时，流的默认权重都是 16.

## 5.4 错误处理

HTTP/2 成帧过程产生的错误会分为两类：
+ 当一个错误导致整个连接不可用时，这种情况视为一个连接错误。
+ 独立于流的错误属于流错误。
错误码的列表包含在 [第七节](https://github.com/abbshr/rfc7540-translation-zh_cn/blob/master/7-zh-cn.md).

### 5.4.1 连接错误处理

任何妨碍帧处理过程或破坏任何连接状态的错误都属于连接错误。
当一个端系统遭遇了连接错误时应该首先通过最后与其对等端成功交互的流发送一个 GOAWAY 帧。GOAWAY 帧包含一个用于说明连接终止原因错误码。发送了 GOAWAY 帧之后，端系统必须要关闭 TCP 连接。
对等方很有可能收不到这个 GOAWAY 帧 ([RFC7230 中 6.6 小节](https://tools.ietf.org/html/rfc7230#section-6.6) 描述了立即关闭的连接如何导致的数据丢失）. 在连接错误发生的情况下，GOAWAY 帧只是"尽力而为"的尝试与其接收对等端交流，告诉它为何终止了连接。
一个端系统可以在任何时间结束连接。特别是，端系统可以选择性的将流错误视为连接错误。端系统在断开连接时应该发送一个 GOAWAY 帧，所以提供的时候就发送它。
### 5.4.2 流错误处理

流错误是与一个特定的流有关的错误，并且它不会影响其他流的处理。
端系统检测到流错误发生时发送一个 RST_STREAM 帧，包含了发生错误的流的标识符。除此之外还包含一个表明错误类型的错误码。
RST_STREAM 是端系统可以在一个流上发送的最后一个帧。发送 RST_STREAM 帧的对等端必须准备接收其远程端点发送的任何正在传输链路上或入队等待发送的帧。可以忽略那些不会改变连接状态的帧 （比如维护头部压缩的状态或流控）.

通常情况下，端系统不应该在任何一个流上发送多于一个的 RST_STERAM 帧。然而，如果在多于一个 RTT 的时间里，端系统再次从一个已经 closed 的流上收到了帧，那么它就可以发送额外的 RST_STREAM 帧。后面描述这一行为用于对付那些未严格遵守标准的协议实现。
为了避免循环发送，端系统不允许再以一个 RST_STREAM 作为对接收到的 RST_STREAM 的响应。
### 5.4.3 连接终止

如果 TCP 连接在流仍处于 open 或 half-closed 状态时关闭了或被重置，然而受影响的流不会去自动重试。（详见 8.1.4 小节）

## 5.5 HTTP/2 扩展

除了协议基本的约定外，允许对其进行扩展。在本章节描述中，协议扩展可以用来提供额外的服务或修改协议的任一部分。需要注意的是扩展功能仅在单个连接范围内有效。
扩展会应用到该文档中定义的协议元素上，但不会影响扩展 HTTP 的现有设置，比如定义新的方法，状态码，头部字段。
扩展允许使用新的帧类型（见 4.1 节）, 新的 settings 参数（见 6.5.2 小节）, 或者使用新的错误码（见第 7 章）. 注册中心会管理这些扩展内容：帧类型（见 11.2 节）, settings 参数（见 11.3 节）, 错误码（见 11.4 节）.

协议实现上必须忽略那些未知的或不支持的扩展值，也必须丢弃那些未知/不支持类型的帧。这意味着所有这些可扩展的地方都可以被安全使用而无需提前安排协商。然而，报头区块中是不允许出现扩展帧的；如果出现就要将其视为一个类型为 PROTOCOL_ERROR 的连接错误来对待。
如果一个扩展可能改变既有协议某部分的语义，必须在使用前商定好。举个例子，一个扩展改变了 HEADERS 帧的结构，那么直到对等方给出一个表示接受变更的信号时，这个扩展才能被应用。这个例子中，可能有必要商定一下修改后的 HEADERS 结构何时起效。除此之外需要注意的是，将任何非 DATA 帧用作流控属于语义上的变化，并且只能通过协商来完成。
该文档并没有描述如何协商使用扩展的方法，但是注意一个 settings 参数就可以用来实现这一目的。如果双方都设置一个值表示愿意使用扩展，扩展即可被启用。如果一个 settings 参数用在了扩展协商上，那么他的初始值在设置上必须表示扩展在最初是被禁用的。
